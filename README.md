# Lattice Boltzmann Method Simulation Project

## Overview

Welcome to my Lattice Boltzmann Method (LBM) Simulation Project! This project is a framework for simulating fluid dynamics using the Lattice Boltzmann Method. The project is divided into two main components:

1. **C++ Program:** The core of the simulation, handling the main computational task.
2. **Python Program (post_processing.py):** Used for post-processing the simulation data generated by the C++ program.

## Build Requirements

- (optional) ccache: For faster compilation
- (optional) ninja-build: For faster compilation
- (optional) Doxygen: For generating Doxygen documentation

## Key Features

- **Modular Design:** _Feature not yet implemented_: Create custom simulations by connecting various functions (initial conditions, boundary conditions, exit conditions, solver types) in a specific way using C++ code. This modular approach also allows for advanced tasks, such as running multiple simulations sequentially and performing error convergence studies.
- **Simulation dimensions:** _Feature not yet implemented_: Choose between 1D, 2D, and 3D simulations.
- **Solver types:**
  - LBM
  - _Feature not yet implemented_: KBC
  - _Feature not yet implemented_: LBM_exact_difference
- **Analytical solutions / initial conditions:**
  - 2D Poisseuille flow with constant Fx (force)
  - 2D Taylor Green flow
  - _Feature not yet implemented_: 3D Taylor Green flow
- **High performance:** Efficient (I hope, just a mechanical engineer here ;) ) c++ code for computations.
- **Versatile post-processing:** Python script to visualize simulation results.
- \*\*Doxygen documentation

## Main Functions

### C++ Functions

Currently, there are two main functions in the C++ codebase that users should modify according to their requirements:

- **`main()`:** The entry point of the simulation program.
- **`initial_condition()`:** Defines the initial conditions for the simulation.

### Missing Functions

The following functions are not yet implemented and need to be completed by the user:

- **`boundary_condition()`:** Defines the boundary conditions for the simulation.
- **`analytical_solution()`:** Provides analytical solutions for comparison with simulation results.

## User Guide

### Building using cmake

- Ninja

  ```zsh
  cd ./build
  cmake .. -G Ninja -DCMAKE_BUILD_TYPE=Release
  cmake --build -j8
  ```

- Windows (my windows system defaults to msvc so i don't have to specify the visual studio toochain)
  ```zsh
  cd ./build
  cmake ..
  cmake --build -j8 --config Release
  ```

### Profiling

#### Linux w/ gprof & gprof2dot

- create `py_venv`
  ```zsh
  cd <project root directory>
  python3 -m venv py_venv
  ```
  If you want to use another name make sure to exclude the venv direcory in the `.gitignore`.
- activate `py_venv` and install gprof2dot
  ```zsh
  cd <project root directory>
  source py_env/bin/activate
  pip install gprof2dot
  ```
- Enter build direcotry and generate dot graph of profile
  ```zsh
    cd <build directory>
  gprof ./LBM gmon.out | gprof2dot -s -w | dot -Gdpi=200 -Tpng -o profile.png
  ```

#### Linux w/ pprof (google profiling toolset)

Prerequisites

- install go `sudo apt install golang`
- install pprof (see [github repo](https://github.com/google/pprof)
  ```zsh
  go install github.com/google/pprof@latest
  ```
- install libgoogle-perftools-dev

Running

```zsh
cd <build directory>
cmake .. -G Ninja -DCMAKE_BUILD_TYPE=Debug
cmake --build . -j8
CPUPROFILE=./LBM.prof ./LBM
pprof -http=localhost:8080 ./LBM LBM.prof
```

### Programming (How to adapt code to your problem set)

- **TODO**

<!-- ## Contact -->
