#ifndef HELPERS_H
#define HELPERS_H

#define __STDC_WANT_LIB_EXT1__ 1
#define __STDC_LIB_EXT1__

#define _USE_MATH_DEFINES

#include "Eigen/Dense"
#include "lbm_core.h"

/**
 * \enum Log_level
 * \brief Defines the various log levels for logging messages.
 *
 * This enumeration defines different levels of logging messages that can be
 * used to categorize the importance or type of message being logged.
 *
 * - \c LOG_LEVEL_OFF: No logging.
 * - \c LOG_LEVEL_ERR: Logs errors using the `print_err` function.
 * - \c LOG_LEVEL_WRN: Logs warnings to the console with the prefix "WARNING".
 * - \c LOG_LEVEL_INF: Logs informational messages to the console with the
 * prefix "INFO".
 * - \c LOG_LEVEL_DBG: Logs debug messages to the console with the prefix
 * "DEBUG".
 *
 * These log levels can be used to control the amount and type of logging output
 * generated by the program.
 *
 * \see log: Logging function.
 * \see LOG_LEVEL: Globally set log-level.
 * \see print_err: Function for printing errors.
 *
 */
// clang-format off
typedef enum {
  LOG_LEVEL_OFF = 0, ///< No logging.
  LOG_LEVEL_ERR, ///< Logs errors to the console with the prefix "ERROR" (using the `print_err` function)
  LOG_LEVEL_WRN, ///< Logs warnings to the console with the prefix "WARNING"
  LOG_LEVEL_INF, ///< Logs informational messages to the console with the prefix "INFO"
  LOG_LEVEL_DBG ///< Logs debug messages to the console with the prefix "DEBUG"
} Log_level;
// clang-format on

/**
 * \def LOG_LEVEL
 * \brief Defines the global log level for the logging system.
 *
 * This macro defines the global log level for the logging system. Messages
 * with a log level higher than this value will not be logged. The log level
 * can be adjusted to control the verbosity of logging output.
 *
 * \see log: Logging function
 * \see Log_level: Different kinds of log levels
 */
#define LOG_LEVEL LOG_LEVEL_DBG

void log(const std::string &filename, const std::string &message,
         const Log_level log_level);

/**
 * \def LOG_ERR(filename, message)
 * \brief Logs an error message.
 *
 * This macro logs an error using the `print_err` and `log` functions with the
 * error log level.
 *
 * \param[in] filename The name of the file from which the log message
 * originates.
 * \param[in] message The error message to be logged.
 *
 * \see LOG_LEVEL: Globally set log-level.
 * \see Log_level: Different kinds of log levels.
 * \see log: Logging function.
 * \see print_err: Function for printing errors.
 */
#define LOG_ERR(filename, message) log(filename, message, LOG_LEVEL_ERR)
/**
 * \def LOG_WRN(filename, message)
 * \brief Logs a warning message.
 *
 * This macro logs a warning message using the `log` function with the
 * warning log level.
 *
 * \param[in] filename The name of the file from which the log message
 * originates.
 * \param[in] message The warning message to be logged.
 *
 * \see LOG_LEVEL: Globally set log-level.
 * \see Log_level: Different kinds of log levels.
 * \see log: Logging function.
 */
#define LOG_WRN(filename, message) log(filename, message, LOG_LEVEL_WRN)
/**
 * \def LOG_INF(filename, message)
 * \brief Logs a info message.
 *
 * This macro logs a info message using the `log` function with the
 * info log level.
 *
 * \param[in] filename The name of the file from which the log message
 * originates.
 * \param[in] message The info message to be logged.
 *
 * \see LOG_LEVEL: Globally set log-level.
 * \see Log_level: Different kinds of log levels.
 * \see log: Logging function.
 */
#define LOG_INF(filename, message) log(filename, message, LOG_LEVEL_INF)
/**
 * \def LOG_DBG(filename, message)
 * \brief Logs a debug message.
 *
 * This macro logs a debug message using the `log` function with the
 * debug log level.
 *
 * \param[in] filename The name of the file from which the log message
 * originates.
 * \param[in] message The debug message to be logged.
 *
 * \see LOG_LEVEL: Globally set log-level.
 * \see Log_level: Different kinds of log levels.
 * \see log: Logging function.
 */
#define LOG_DBG(filename, message) log(filename, message, LOG_LEVEL_DBG)

/**
 * \brief Performs a circular roll operation on a 2D Eigen matrix (similar to
 * numpy.roll).
 *
 * This function shifts the elements of a 2D Eigen array along its rows and
 * columns. Positive shift values move elements in the right/down direction,
 * while negative values move them in the left/up direction. The shift is
 * performed circularly, meaning elements shifted off one end will reappear at
 * the other end.
 *
 * \param[in,out] array The 2D Eigen array to be shifted. The array is modified
 * in place.
 * \param[in] gridsize A array with the gridsize of the simulation in the format
 * [Nx, Ny, Nz]
 * \param[in] row_shift The number of positions to shift the rows. Positive
 * values shift downward, and negative values shift upward. The shift is
 * circular.
 * \param[in] col_shift The number of positions to shift the columns. Positive
 * values shift to the right, and negative values shift to the left. The shift
 * is circular.
 *
 * \note The shift is performed in place, meaning the input array is modified
 * directly.
 */
template <typename T>
void roll2D(Eigen::Array<T, Eigen::Dynamic, Eigen::Dynamic> &array,
            const Gridsize &gridsize, int row_shift, int col_shift) {
  const int cols = static_cast<int>(gridsize[0]);
  const int rows = static_cast<int>(gridsize[1]);

  // Handle row shift
  row_shift = (row_shift % rows + rows) % rows;
  if (row_shift != 0) {
    Eigen::Array<T, Eigen::Dynamic, Eigen::Dynamic> tmp =
        array.bottomRows(row_shift);
    if (row_shift * 2 < rows) {
      // Here aliasing occurs
      array.bottomRows(rows - row_shift) =
          array.topRows(rows - row_shift).eval();
    } else {
      array.bottomRows(rows - row_shift) = array.topRows(rows - row_shift);
    }
    array.topRows(row_shift) = tmp;
  }

  // Handle column shift
  col_shift = (col_shift % cols + cols) % cols;
  if (col_shift != 0) {
    Eigen::Array<T, Eigen::Dynamic, Eigen::Dynamic> tmp =
        array.rightCols(col_shift);
    if (col_shift * 2 < cols) {
      // here aliasing occurs
      array.rightCols(cols - col_shift) =
          array.leftCols(cols - col_shift).eval();
    } else {
      array.rightCols(cols - col_shift) = array.leftCols(cols - col_shift);
    }
    array.leftCols(col_shift) = tmp;
  }
}

Grid meshgrid(const Gridsize &gridsize, const GridVectors &gridvectors);

Eigen::ArrayXXd curlZ(const Eigen::ArrayXXd &ux, const Eigen::ArrayXXd &uy,
                      const Gridsize &gridsize, const double dr);

#endif // HELPERS_H
